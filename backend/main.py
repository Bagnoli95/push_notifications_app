from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
from typing import Optional, List
import jwt
import bcrypt
import cx_Oracle
from datetime import datetime, timedelta
import firebase_admin
from firebase_admin import credentials, messaging
import os
from contextlib import contextmanager
import uuid
from dotenv import load_dotenv

# Cargar variables de entorno
load_dotenv()

app = FastAPI(title="Push Notifications API")
security = HTTPBearer()

# Configuración desde variables de entorno
SENDER_ID = int(os.getenv("SENDER_ID", "0"))
SERVER_KEY = os.getenv("SERVER_KEY", "")
FIREBASE_CREDENTIALS_PATH = os.getenv("FIREBASE_CREDENTIALS_PATH", "./push-notifications-app.json")

# JWT Configuration
SECRET_KEY = os.getenv("SECRET_KEY", "fallback-secret-key-change-this")
ALGORITHM = os.getenv("ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30"))

# Oracle Database Configuration
ORACLE_USER = os.getenv("ORACLE_USER", "")
ORACLE_PASSWORD = os.getenv("ORACLE_PASSWORD", "")
ORACLE_DSN = os.getenv("ORACLE_DSN", "localhost:1521/XE")

# Server Configuration
HOST = os.getenv("HOST", "0.0.0.0")
PORT = int(os.getenv("PORT", "8000"))
ENVIRONMENT = os.getenv("ENVIRONMENT", "development")

# Validar variables críticas
if not ORACLE_USER or not ORACLE_PASSWORD:
    raise ValueError("ORACLE_USER and ORACLE_PASSWORD must be set in .env file")

if not SERVER_KEY:
    raise ValueError("SERVER_KEY must be set in .env file")

if not os.path.exists(FIREBASE_CREDENTIALS_PATH):
    raise ValueError(f"Firebase credentials file not found: {FIREBASE_CREDENTIALS_PATH}")

# Inicializar Firebase Admin
try:
    cred = credentials.Certificate(FIREBASE_CREDENTIALS_PATH)
    firebase_admin.initialize_app(cred)
    print(f"✅ Firebase initialized successfully with project: {cred.project_id}")
except Exception as e:
    print(f"❌ Error initializing Firebase: {e}")
    raise

# Modelos Pydantic
class UserRegister(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class DeviceRegister(BaseModel):
    fcm_token: str
    device_id: str

class PushNotification(BaseModel):
    title: str
    body: str
    user_id: Optional[int] = None
    username: Optional[str] = None

class InternalNotification(BaseModel):
    title: str
    message: str
    user_id: Optional[int] = None
    username: Optional[str] = None

# Conexión a Oracle
@contextmanager
def get_db_connection():
    connection = None
    try:
        connection = cx_Oracle.connect(ORACLE_USER, ORACLE_PASSWORD, ORACLE_DSN)
        yield connection
    except cx_Oracle.Error as e:
        print(f"Oracle connection error: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Database connection failed"
        )
    finally:
        if connection:
            connection.close()

# Funciones de utilidad
def hash_password(password: str) -> str:
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate credentials"
            )
        return payload
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials"
        )

# Inicializar tablas
def init_database():
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            
            # Tabla usuarios - manejo de errores para Oracle
            try:
                cursor.execute("""
                    CREATE TABLE users (
                        id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        username VARCHAR2(50) UNIQUE NOT NULL,
                        email VARCHAR2(100) UNIQUE NOT NULL,
                        password_hash VARCHAR2(255) NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                print("✅ Table 'users' created")
            except cx_Oracle.DatabaseError as e:
                if "ORA-00955" in str(e):  # Table already exists
                    print("ℹ️ Table 'users' already exists")
                else:
                    raise
            
            # Tabla devices
            try:
                cursor.execute("""
                    CREATE TABLE devices (
                        id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        user_id NUMBER REFERENCES users(id),
                        device_id VARCHAR2(255) NOT NULL,
                        fcm_token VARCHAR2(500) NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                print("✅ Table 'devices' created")
            except cx_Oracle.DatabaseError as e:
                if "ORA-00955" in str(e):
                    print("ℹ️ Table 'devices' already exists")
                else:
                    raise
            
            # Tabla notificaciones internas
            try:
                cursor.execute("""
                    CREATE TABLE internal_notifications (
                        id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        user_id NUMBER REFERENCES users(id),
                        title VARCHAR2(255) NOT NULL,
                        message CLOB NOT NULL,
                        is_read NUMBER(1) DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                print("✅ Table 'internal_notifications' created")
            except cx_Oracle.DatabaseError as e:
                if "ORA-00955" in str(e):
                    print("ℹ️ Table 'internal_notifications' already exists")
                else:
                    raise
            
            conn.commit()
            print("✅ Database initialization completed")
            
    except Exception as e:
        print(f"❌ Database initialization failed: {e}")
        if ENVIRONMENT == "development":
            print("ℹ️ Continuing in development mode...")
        else:
            raise

# Inicializar DB al inicio
init_database()

@app.get("/")
async def root():
    return {
        "message": "Push Notifications API",
        "environment": ENVIRONMENT,
        "version": "1.0.0",
        "docs": "/docs"
    }

@app.post("/register")
async def register_user(user: UserRegister):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        # Verificar si usuario ya existe
        cursor.execute("SELECT id FROM users WHERE username = :1 OR email = :2", 
                      (user.username, user.email))
        if cursor.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username or email already registered"
            )
        
        # Crear usuario
        hashed_password = hash_password(user.password)
        cursor.execute("""
            INSERT INTO users (username, email, password_hash) 
            VALUES (:1, :2, :3)
        """, (user.username, user.email, hashed_password))
        conn.commit()
        
        return {"message": "User registered successfully"}

@app.post("/login")
async def login_user(user: UserLogin):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT id, username, password_hash 
            FROM users WHERE username = :1
        """, (user.username,))
        
        db_user = cursor.fetchone()
        if not db_user or not verify_password(user.password, db_user[2]):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password"
            )
        
        access_token = create_access_token(data={"sub": user.username, "user_id": db_user[0]})
        
        return {
            "access_token": access_token,
            "token_type": "bearer",
            "user_id": db_user[0],
            "username": db_user[1]
        }

@app.post("/register-device")
async def register_device(device: DeviceRegister, current_user = Depends(verify_token)):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        user_id = current_user["user_id"]
        
        # Verificar si el device ya existe para este usuario
        cursor.execute("""
            SELECT id FROM devices 
            WHERE user_id = :1 AND device_id = :2
        """, (user_id, device.device_id))
        
        existing_device = cursor.fetchone()
        
        if existing_device:
            # Actualizar token FCM
            cursor.execute("""
                UPDATE devices 
                SET fcm_token = :1, updated_at = CURRENT_TIMESTAMP
                WHERE user_id = :2 AND device_id = :3
            """, (device.fcm_token, user_id, device.device_id))
        else:
            # Crear nuevo registro de device
            cursor.execute("""
                INSERT INTO devices (user_id, device_id, fcm_token)
                VALUES (:1, :2, :3)
            """, (user_id, device.device_id, device.fcm_token))
        
        conn.commit()
        return {"message": "Device registered successfully"}

@app.post("/send-push-notification")
async def send_push_notification(notification: PushNotification, current_user = Depends(verify_token)):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        # Obtener tokens FCM
        if notification.user_id:
            cursor.execute("SELECT fcm_token FROM devices WHERE user_id = :1", (notification.user_id,))
        elif notification.username:
            cursor.execute("""
                SELECT d.fcm_token FROM devices d
                JOIN users u ON d.user_id = u.id
                WHERE u.username = :1
            """, (notification.username,))
        else:
            cursor.execute("SELECT fcm_token FROM devices")
        
        tokens = [row[0] for row in cursor.fetchall()]
        
        if not tokens:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="No devices found"
            )
        
        # Enviar notificación push
        try:
            message = messaging.MulticastMessage(
                notification=messaging.Notification(
                    title=notification.title,
                    body=notification.body
                ),
                data={
                    'click_action': 'FLUTTER_NOTIFICATION_CLICK',
                    'type': 'push_notification'
                },
                tokens=tokens
            )
            
            response = messaging.send_multicast(message)
            
            return {
                "message": "Push notification sent",
                "success_count": response.success_count,
                "failure_count": response.failure_count,
                "tokens_used": len(tokens)
            }
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to send notification: {str(e)}"
            )

@app.post("/send-internal-notification")
async def send_internal_notification(notification: InternalNotification, current_user = Depends(verify_token)):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        # Obtener user_ids objetivo
        user_ids = []
        if notification.user_id:
            user_ids = [notification.user_id]
        elif notification.username:
            cursor.execute("SELECT id FROM users WHERE username = :1", (notification.username,))
            user = cursor.fetchone()
            if user:
                user_ids = [user[0]]
        else:
            cursor.execute("SELECT id FROM users")
            user_ids = [row[0] for row in cursor.fetchall()]
        
        if not user_ids:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="No users found"
            )
        
        # Insertar notificaciones internas
        for user_id in user_ids:
            cursor.execute("""
                INSERT INTO internal_notifications (user_id, title, message)
                VALUES (:1, :2, :3)
            """, (user_id, notification.title, notification.message))
        
        conn.commit()
        
        return {
            "message": "Internal notifications sent",
            "count": len(user_ids)
        }

@app.get("/internal-notifications")
async def get_internal_notifications(current_user = Depends(verify_token)):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        user_id = current_user["user_id"]
        
        cursor.execute("""
            SELECT id, title, message, is_read, created_at
            FROM internal_notifications
            WHERE user_id = :1
            ORDER BY created_at DESC
        """, (user_id,))
        
        notifications = []
        for row in cursor.fetchall():
            notifications.append({
                "id": row[0],
                "title": row[1],
                "message": row[2],
                "is_read": bool(row[3]),
                "created_at": row[4].isoformat() if row[4] else None
            })
        
        return {"notifications": notifications}

@app.put("/internal-notifications/{notification_id}/read")
async def mark_notification_as_read(notification_id: int, current_user = Depends(verify_token)):
    with get_db_connection() as conn:
        cursor = conn.cursor()
        user_id = current_user["user_id"]
        
        cursor.execute("""
            UPDATE internal_notifications 
            SET is_read = 1
            WHERE id = :1 AND user_id = :2
        """, (notification_id, user_id))
        
        if cursor.rowcount == 0:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Notification not found"
            )
        
        conn.commit()
        return {"message": "Notification marked as read"}
    
@app.get("/health")
async def health_check():
    status = {
        "environment": ENVIRONMENT,
        "timestamp": datetime.utcnow().isoformat()
    }
    
    # Test Oracle
    try:
        with get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT 1 FROM dual")
            result = cursor.fetchone()
            status["oracle"] = {
                "status": "✅ Connected",
                "dsn": ORACLE_DSN,
                "user": ORACLE_USER,
                "test_query": result[0] if result else None
            }
    except Exception as e:
        status["oracle"] = {
            "status": f"❌ Error: {str(e)}",
            "dsn": ORACLE_DSN,
            "user": ORACLE_USER
        }
    
    # Test Firebase
    try:
        app_instance = firebase_admin.get_app()
        status["firebase"] = {
            "status": "✅ Initialized",
            "project_id": app_instance.project_id if hasattr(app_instance, 'project_id') else "unknown"
        }
    except Exception as e:
        status["firebase"] = {
            "status": f"❌ Error: {str(e)}",
            "credentials_path": FIREBASE_CREDENTIALS_PATH
        }
    
    # Configuration summary
    status["config"] = {
        "sender_id": SENDER_ID,
        "server_key_configured": bool(SERVER_KEY),
        "secret_key_configured": bool(SECRET_KEY),
        "host": HOST,
        "port": PORT
    }
        
    return status

if __name__ == "__main__":
    import uvicorn
    print(f"🚀 Starting server in {ENVIRONMENT} mode...")
    print(f"📊 Health check available at: http://{HOST}:{PORT}/health")
    print(f"📖 API docs available at: http://{HOST}:{PORT}/docs")
    uvicorn.run(app, host=HOST, port=PORT)